#include <Adafruit_LiquidCrystal.h>
Adafruit_LiquidCrystal Pantalla (0);
unsigned long TiempoInicio= 0;
unsigned long TiempoFin= 0;
unsigned int Muestreo;
int senal= A1;
int Cap= 20;
int Pulsador = 2;
byte PulsadorFin= 4;
int* Info = new int [Cap];

/*______________________________________________________________

					DEFINICION DE FUNCIONES
  Encabezados de las funciones y una descripcion corta de ellas
______________________________________________________________*/

bool Cuadrado(int* Info, int& Cap);
bool Seno(int* Info, int& Cap, int Inicio, int Amp, int Frec);
bool Triangulo(int* Info, int& Cap);
int Forma(int* Info, int& Cap, int Inicio, int Amp, int Frec);

void AumentoCapacidad(int*& Arr, int& Cap);
int Datos(int TiempoInicio, int*& Info, int& Cap);

int Amplitud(int* Info, int CantData);
int Frecuencia(int* Info, int CantData);

/*______________________________________________________________

					FUNCIONES DE ARDUINO
				   Void setup y Void loop
______________________________________________________________*/

void setup()
{
  Serial.begin(9600);
  Pantalla.begin(16,2);
  Pantalla.setCursor(0,0);
  pinMode(Pulsador,INPUT);
  pinMode(PulsadorFin,INPUT);
  
}

void loop()
{
  if(digitalRead(Pulsador)==HIGH){
    int CantDatos=0;
    TiempoInicio=millis();
   	CantDatos=Datos(TiempoInicio, Info, Cap);
    Pantalla.setCursor(0,1);
    int Amp = Amplitud(Info, CantDatos);
	Pantalla.print("A="); Pantalla.print(Amp);
    Pantalla.setCursor(6,1);
    int Frec = Frecuencia(Info, CantDatos);
    Pantalla.print("F=");Pantalla.print(Frec);
    Pantalla.setCursor(0,0);
    Pantalla.print(Forma(Info, CantDatos, TiempoInicio, Amp, Frec));
  }

}

/*______________________________________________________________

					FUNCIONES DE FORMA
			Funciones para verificar la forma de la onda
______________________________________________________________*/

bool Cuadrado(int* Info, int& Cap){
  int Val1=Info[1];
  int Val2=Val1;
  byte contVal=0;
  for (int i = 0; i<Cap; i++){
    if ((Info[i]!=Val1)&&(Info[i]!=Val2)){
      Val2=Info[i];
      contVal++;
    }
    if (contVal>1){
      return false;
    }
  }
  if (contVal==0){
    return false;
  }
  
  return true;
}

bool Seno(int* Info, int& Cap, int Inicio, int Amp, int Frec){
  float x=0;
  int CantExtra=0;
  float ErrorAcum = 0;
  float Error=0;
  int* DataExtra=AjusteSeno(Info,Cap,CantExtra, Amp, Frec);
  float Ajuste=AjusteHorizontalSeno(DataExtra[0], Amp, Frec);
  
  int cont=0;
    
  for (int i=0;i<CantExtra;i++){
  	Serial.print(100*(Amp)*sin(2*3.14*(Frec)*(x+Ajuste)));Serial.print("/");Serial.println(DataExtra[i]);
	Error=100*(Amp)*sin(2*3.14*(Frec)*(x+Ajuste))-DataExtra[i];
    ErrorAcum+=abs(Error);

    x+=0.01;
  }
  Serial.println("Cambio");
  int Prueba = 100*(Amp)*sin(2*3.14*(Frec)*(x+Ajuste));
  if(abs(Prueba-Info[0])>abs(Prueba-Info[1])){
    cont=1;
  }
  for (cont;cont<Cap;cont++){
  	Serial.print(100*(Amp)*sin(2*3.14*(Frec)*(x+Ajuste)));Serial.print("/");Serial.println(Info[cont]);
    Error=100*(Amp)*sin(2*3.14*(Frec)*(x+Ajuste))-Info[cont];
    ErrorAcum+=abs(Error);
    x+=0.01;
    
  }
  Serial.print("Diffs ");Serial.print(abs(Prueba-Info[0]));Serial.print("/");Serial.println(abs(Prueba-Info[1]));
  Serial.print("Sin Data Inicio ");Serial.print(100*(Amp)*sin(2*3.14*(Frec)*(Ajuste)));Serial.print("/");Serial.println(DataExtra[0]);
  Serial.print("Sin Data Fin ");Serial.print(100*(Amp)*sin(2*3.14*(Frec)*(Ajuste+(0.01*(CantExtra-1)))));Serial.print("/");Serial.println(DataExtra[CantExtra-1]);
  Serial.print("Sin Info 0 ");Serial.print(100*(Amp)*sin(2*3.14*(Frec)*(Ajuste+(0.01*CantExtra))));Serial.print("/");Serial.println(Info[0]);
  Serial.print("Sin Info 1 ");Serial.print(100*(Amp)*sin(2*3.14*(Frec)*(Ajuste+(0.01*(CantExtra+1)))));Serial.print("/");Serial.println(Info[1]);
  Serial.print("Data ");Serial.print(DataExtra[0]);Serial.print("/");Serial.println(DataExtra[CantExtra-1]);
  Serial.print("Info ");Serial.print(Info[0]);Serial.print("/");Serial.print(Info[1]);Serial.print("/");Serial.println(Info[2]);
  delete[] DataExtra;
  Serial.print("Err ");Serial.println(ErrorAcum/(CantExtra+Cap));
  Serial.print("Cap ");Serial.println(CantExtra+Cap);
  int Limite = Amp*5;
  if (ErrorAcum/(CantExtra+Cap) < Limite){
   	return true; 
  }
  return false;
}


bool Triangulo(int* Info, int& Cap){
  /*int diffmax=0;
  int pendiente = abs(Info[0]-Info[1]);
  int diff=0;
  for (int i = 1; i<Cap-1; i++){
    diff=abs(Info[i]-Info[i+1]);
    Serial.print(diff);Serial.print("/");Serial.println(pendiente);
    if (diff>diffmax){
      diffmax=diff;
    }
	}
  Serial.println(diffmax);*/
  return false;
}

int Forma(int* Info, int& Cap, int Inicio, int Amp, int Frec){
  if (Cuadrado(Info, Cap)){
    return 1;
  }
  else if (Seno(Info, Cap, Inicio, Amp, Frec)){
    
    return 2;
  }
  else if (Triangulo(Info, Cap)){
    return 3;
  }
  else{
    return 0;
  }
}
/*______________________________________________________________

					FUNCIONES DE DATOS
Funciones para crear las estructuras de datos, y administrarlas
_______________________________________________________________*/

void AumentoCapacidad(int*& Arr, int& Cap){
  int CapNew = Cap+20;
  int* Aux = new int [CapNew];
  for (int i = 0; i<Cap; i++){
    *(Aux+i)=*(Arr+i);
  }
  delete[] Arr;
  Arr=Aux;
  Cap=CapNew;
}

int Datos(int TiempoInicio, int*& Info, int& Cap){
  Muestreo=TiempoInicio/10;
  int numData=0;
  while (digitalRead(PulsadorFin)==LOW){
    if (Muestreo!=millis()/10){
      Info[numData]=analogRead(senal);
      	Muestreo=millis()/10;
      	numData++;
    }
    if (numData>=Cap){
    	AumentoCapacidad(Info, Cap);
    }
      Serial.println(numData);
  }

  return numData;
}

int* AjusteSeno (int*& Info, int CantDatos, int& CantDataExtra, int Amp, int Frec){
  bool Neg=false;
  int Cambios=0;
  int pos = 0;
  int signo = 1;
  if (Info[0]<0){
    Neg=true;
  }
  
  if (Neg){
    for (int i = 0; i<CantDatos; i++){
      Info[i]=-(Info[i]);
    }
  }
  
  if (Info[0]<=Info[1]){
    while ((Cambios<2)&&(pos<CantDatos)){
      if ((signo*Info[pos])<0){
        Cambios++;
        signo*=-1;
        }
      pos++;
      }
    while (Info[pos]<Info[0]){
      CantDataExtra++;
      pos++;
      }
    
    int* InfoExtra=new int[CantDataExtra];
    for (int i = 0; i<CantDataExtra;i++){
      InfoExtra[i]=Info[pos-1-CantDataExtra+i];
    	}
    return InfoExtra;
  	}
  
  else{
    while ((Cambios<2)&&(pos<CantDatos)){
      if ((signo*Info[pos])<0){
        Cambios++;
        signo*=-1;
        }
      pos++;
      }
    while (Info[pos]<Info[0]){
      CantDataExtra++;
      pos++;
      }
    while (Info[pos]>Info[0]){
      CantDataExtra++;
      pos++;
      }
    int* InfoExtra=new int[CantDataExtra];
    for (int i = 0; i<CantDataExtra;i++){
      InfoExtra[i]=Info[pos-CantDataExtra+i];
    	}
    return InfoExtra;
  	}
}

float AjusteHorizontalSeno (int Pos0, int Amp, int Frec){
  float Ajuste = 0;
  int Val = 0;
  while (Pos0>Val){
    Ajuste+=0.002/(Amp*Frec);
    Val=100*(Amp)*sin(2*3.14*(Frec)*(Ajuste));
  }
  return Ajuste;
}

/*______________________________________________________________

					FUNCIONES DE ONDA
Funciones para determinar la amplitud y frecuencia de las ondas
_______________________________________________________________*/

int Amplitud(int* Info, int CantData){
  int Max=Info[0], Min=Info[0], Amp;
  for (int i=1; i<CantData; i++){
    if (Info[i]>Max){
      Max=Info[i];
    	}
    if (Info[i]<Min){
      Min=Info[i];
  		}
    Amp=abs(Max)+abs(Min);
    if (Amp%100!=0){
      Amp+=Amp%100;
    	}
	}
  int Centro = (Max + Min)/2;
  if (Centro!=0){
  	for (int i=0; i<CantData; i++){
    	Info[i]-=Centro;
  	}
  }
  return Amp/200;
}
  
int Frecuencia(int* Info, int CantData){
  bool Neg = false;
  int Frec=0, i=0;
  if (Info[0]<0){
      Neg = true;
      }
  while (i<CantData){
    while (Neg){
      if (Info[i]>=0){
        Frec++;
        Neg=!Neg;
        }
      i++;
    }
    while (!Neg){
      if (Info[i]<0){
        Frec++;
        Neg=!Neg;
        }
      i++;
      }
  }
  return Frec/4;
}