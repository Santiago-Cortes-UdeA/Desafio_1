#include <Adafruit_LiquidCrystal.h>
Adafruit_LiquidCrystal Pantalla (0);
unsigned long TiempoInicio= 0;
unsigned long TiempoFin= 0;
unsigned int Muestreo;
int senal= A1;
int Cap= 20;
int Pulsador = 2;
byte PulsadorFin= 4;
int* Info = new int [Cap];

bool Cuadrado(int* Info, int& Cap);
bool Seno(int* Info, int& Cap, int Inicio);
bool Triangulo(int* Info, int& Cap);
int Forma(int* Info, int& Cap, int Inicio);

void AumentoCapacidad(int*& Arr, int& Cap);
int Datos(int TiempoInicio, int*& Info, int& Cap);

int Amplitud(int* Info, int CantData);
int Frecuencia(int* Info, int CantData);

void setup()
{
  Serial.begin(9600);
  Pantalla.begin(16,2);
  Pantalla.setCursor(0,0);
  pinMode(Pulsador,INPUT);
  pinMode(PulsadorFin,INPUT);
  
}

void loop()
{
  if(digitalRead(Pulsador)==HIGH){
    int CantDatos=0;
    TiempoInicio=millis();
   	CantDatos=Datos(TiempoInicio, Info, Cap);
    Pantalla.setCursor(0,1);
	Pantalla.print("A="); Pantalla.print(Amplitud(Info, CantDatos));
    Pantalla.setCursor(6,1);
    Pantalla.print("F=");Pantalla.print(Frecuencia(Info, CantDatos));
    Pantalla.setCursor(0,0);
    Pantalla.print(Forma(Info, CantDatos, TiempoInicio));
  }

}

/*______________________________________________________________

					FUNCIONES DE FORMA
			Funciones para verificar la forma de la onda
______________________________________________________________*/

bool Cuadrado(int* Info, int& Cap){
  int Val1=Info[1];
  int Val2=Val1;
  byte contVal=0;
  for (int i = 0; i<Cap; i++){
    if ((Info[i]!=Val1)&&(Info[i]!=Val2)){
      Val2=Info[i];
      contVal++;
    }
    if (contVal>1){
      return false;
    }
  }
  if (contVal==0){
    return false;
  }
  
  return true;
}

bool Seno(int* Info, int& Cap, int Inicio){
  float x=0;
  int CantExtra=0;
  int Error = 0;
  int* DataExtra=AjusteSeno(Info,Cap,CantExtra);
  for (int i=0;i<CantExtra;i++){
  	Serial.print(int(100*sin(4*3.14*x)));Serial.print("/");Serial.println(DataExtra[i]);
    if ((abs(int(100*sin(4*3.14*x))-DataExtra[i])>Error)&&i!=0){
      Error=abs(int(100*sin(4*3.14*x))-DataExtra[i]);
    }
    x+=0.01;
  }
  Serial.println("Cambio");
  for (int i=0;i<Cap;i++){
  	Serial.print(int(100*sin(4*3.14*x)));Serial.print("/");Serial.println(Info[i]);
    if (abs(int(100*sin(4*3.14*x))-Info[i])>Error){
      Error=abs(int(100*sin(4*3.14*x))-Info[i]);
    }
    x+=0.01;
    
  }
  Serial.print(Info[0]);Serial.print("/");Serial.println(Info[1]);
  Serial.println(DataExtra[1]);
  delete[] DataExtra;
  Serial.println(Error);
  Serial.println(Error);
}


bool Triangulo(int* Info, int& Cap){
  int diffmax=0;
  int pendiente = abs(Info[0]-Info[1]);
  int diff=0;
  for (int i = 1; i<Cap-1; i++){
    diff=abs(Info[i]-Info[i+1]);
    Serial.print(diff);Serial.print("/");Serial.println(pendiente);
    if (diff>diffmax){
      diffmax=diff;
    }
	}
  Serial.println(diffmax);
  return true;
}

int Forma(int* Info, int& Cap, int Inicio){
  if (Cuadrado(Info, Cap)){
    return 1;
  }
  else if (Seno(Info, Cap,Inicio)){
    
    return 2;
  }
  else if (Triangulo(Info, Cap)){
    return 3;
  }
  else{
    return 0;
  }
}
/*______________________________________________________________

					FUNCIONES DE DATOS
Funciones para crear las estructuras de datos, y administrarlas
_______________________________________________________________*/

void AumentoCapacidad(int*& Arr, int& Cap){
  int CapNew = Cap+20;
  int* Aux = new int [CapNew];
  for (int i = 0; i<Cap; i++){
    *(Aux+i)=*(Arr+i);
  }
  delete[] Arr;
  Arr=Aux;
  Cap=CapNew;
}

int Datos(int TiempoInicio, int*& Info, int& Cap){
  Muestreo=TiempoInicio/10;
  int numData=0;
  while (digitalRead(PulsadorFin)==LOW){
    if (Muestreo!=millis()/10){
      Info[numData]=analogRead(senal);
      	Muestreo=millis()/10;
      	numData++;
    }
    if (numData>=Cap){
    	AumentoCapacidad(Info, Cap);
    }
      Serial.println(numData);
  }

  return numData;
}

int* AjusteSeno (int*& Info, int CantDatos, int& CantDataExtra){
  bool Neg=false;
  int Cambios=0;
  int pos = 0;
  int signo = 1;
  if (Info[0]<0){
    Neg=true;
  }
  
  if (Neg){
    for (int i = 0; i<CantDatos; i++){
      Info[i]=-(Info[i]);
    }
  }
  
  if (Info[0]<=Info[1]){
    while ((Cambios<2)&&(pos<CantDatos)){
      if ((signo*Info[pos])<0){
        Cambios++;
        signo*=-1;
        }
      pos++;
      }
    while (Info[pos]<Info[0]){
      CantDataExtra++;
      pos++;
      }
    int* InfoExtra=new int[CantDataExtra];
    for (int i = 0; i<CantDataExtra;i++){
      InfoExtra[i]=Info[pos-1-CantDataExtra+i];
    	}
    
    
    /*for (int i=0; i<CantDataExtra; i++){
      Serial.println(InfoExtra[i]);
    }
    Serial.println("Real");
    for (int i=0; i<CantDatos; i++){
      Serial.println(Info[i]);
    }*/
    
    
    return InfoExtra;
  	}
  
  else{
    while ((Cambios<2)&&(pos<CantDatos)){
      if ((signo*Info[pos])<0){
        Cambios++;
        signo*=-1;
        }
      pos++;
      }
    while (Info[pos]<Info[0]){
      CantDataExtra++;
      pos++;
      }
    while (Info[pos]>=Info[0]){
      CantDataExtra++;
      pos++;
      }
    int* InfoExtra=new int[CantDataExtra];
    for (int i = 0; i<CantDataExtra;i++){
      InfoExtra[i]=Info[pos-CantDataExtra+i];
    	}
    return InfoExtra;
  	}
  }


/*______________________________________________________________

					FUNCIONES DE ONDA
Funciones para determinar la amplitud y frecuencia de las ondas
_______________________________________________________________*/

int Amplitud(int* Info, int CantData){
  int Max=0, Min=0, Amp;
  for (int i=0; i<CantData; i++){
    if (Info[i]>Max){
      Max=Info[i];
    	}
    if (Info[i]<Min){
      Min=Info[i];
  		}
    Amp=abs(Max)+abs(Min);
    if (Amp%100!=0){
      Amp+=Amp%100;
    	}
	}
  return Amp/200;
}
  
int Frecuencia(int* Info, int CantData){
  bool Neg = false;
  int Frec=0, i=0;
  if (Info[0]<0){
      Neg = true;
      }
  while (i<CantData){
    while (Neg){
      if (Info[i]>=0){
        Frec++;
        Neg=!Neg;
        }
      i++;
    }
    while (!Neg){
      if (Info[i]<0){
        Frec++;
        Neg=!Neg;
        }
      i++;
      }
  }
  return Frec/4;
}